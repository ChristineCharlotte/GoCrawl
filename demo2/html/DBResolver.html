<div class="article">            <div class="inner">              <header class="article-header">                <h1 class="article-title" itemprop="name">DBResolver</h1>                                <a href="https://translate.gorm.io/project/go-gorm/zh-CN" target="_blank" rel="noopener" class="article-edit-link" title="改进此页面"><i class="fa fa-pencil"></i></a>                              </header>              <div class="article-content" itemprop="articleBody">                <html><head></head><body><p>DBResolver 为 GORM 提供了多个数据库支持，支持以下功能：</p><ul><li>支持多个 sources、replicas</li><li>读写分离</li><li>根据工作表、struct 自动切换连接</li><li>手动切换连接</li><li>Sources/Replicas 负载均衡</li><li>适用于原生 SQL</li></ul><p><a href="https://github.com/go-gorm/dbresolver" target="_blank" rel="noopener">https://github.com/go-gorm/dbresolver</a></p><h2 id="用法" class="article-heading"><a href="#用法" class="headerlink" title="用法"></a>用法<a class="article-anchor" href="#用法" aria-hidden="true"></a></h2><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"gorm.io/gorm"</span></span><br><span class="line">  <span class="string">"gorm.io/plugin/dbresolver"</span></span><br><span class="line">  <span class="string">"gorm.io/driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">db, err := gorm.Open(mysql.Open(<span class="string">"db1_dsn"</span>), &amp;gorm.Config{})</span><br><span class="line"></span><br><span class="line">db.Use(dbresolver.Register(dbresolver.Config{</span><br><span class="line">  <span class="comment">// `db2` 作为 sources，`db3`、`db4` 作为 replicas</span></span><br><span class="line">  Sources:  []gorm.Dialector{mysql.Open(<span class="string">"db2_dsn"</span>)},</span><br><span class="line">  Replicas: []gorm.Dialector{mysql.Open(<span class="string">"db3_dsn"</span>), mysql.Open(<span class="string">"db4_dsn"</span>)},</span><br><span class="line">  <span class="comment">// sources/replicas 负载均衡策略</span></span><br><span class="line">  Policy: dbresolver.RandomPolicy{},</span><br><span class="line">}).Register(dbresolver.Config{</span><br><span class="line">  <span class="comment">// `db1` 作为 sources（DB 的默认连接），对于 `User`、`Address` 使用 `db5` 作为 replicas</span></span><br><span class="line">  Replicas: []gorm.Dialector{mysql.Open(<span class="string">"db5_dsn"</span>)},</span><br><span class="line">}, &amp;User{}, &amp;Address{}).Register(dbresolver.Config{</span><br><span class="line">  <span class="comment">// `db6`、`db7` 作为 sources，对于 `orders`、`Product` 使用 `db8` 作为 replicas</span></span><br><span class="line">  Sources:  []gorm.Dialector{mysql.Open(<span class="string">"db6_dsn"</span>), mysql.Open(<span class="string">"db7_dsn"</span>)},</span><br><span class="line">  Replicas: []gorm.Dialector{mysql.Open(<span class="string">"db8_dsn"</span>)},</span><br><span class="line">}, <span class="string">"orders"</span>, &amp;Product{}, <span class="string">"secondary"</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="事务" class="article-heading"><a href="#事务" class="headerlink" title="事务"></a>事务<a class="article-anchor" href="#事务" aria-hidden="true"></a></h2><p>使用 transaction 时，DBResolver 也会使用一个事务，且不会切换 sources/replicas 连接</p><h2 id="自动切换连接" class="article-heading"><a href="#自动切换连接" class="headerlink" title="自动切换连接"></a>自动切换连接<a class="article-anchor" href="#自动切换连接" aria-hidden="true"></a></h2><p>DBResolver 会根据工作表、struct 自动切换连接</p><p>对于原生 SQL，DBResolver 会从 SQL 中提取表名以匹配 Resolver，除非 SQL 开头为 <code>SELECT</code>（select for update 除外），否则 DBResolver 总是会使用 <code>sources</code> ，例如：</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// `User` Resolver 示例</span></span><br><span class="line">db.Table(<span class="string">"users"</span>).Rows() <span class="comment">// replicas `db5`</span></span><br><span class="line">db.Model(&amp;User{}).Find(&amp;AdvancedUser{}) <span class="comment">// replicas `db5`</span></span><br><span class="line">db.Exec(<span class="string">"update users set name = ?"</span>, <span class="string">"jinzhu"</span>) <span class="comment">// sources `db1`</span></span><br><span class="line">db.Raw(<span class="string">"select name from users"</span>).Row().Scan(&amp;name) <span class="comment">// replicas `db5`</span></span><br><span class="line">db.Create(&amp;user) <span class="comment">// sources `db1`</span></span><br><span class="line">db.Delete(&amp;User{}, <span class="string">"name = ?"</span>, <span class="string">"jinzhu"</span>) <span class="comment">// sources `db1`</span></span><br><span class="line">db.Table(<span class="string">"users"</span>).Update(<span class="string">"name"</span>, <span class="string">"jinzhu"</span>) <span class="comment">// sources `db1`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Global Resolver 示例</span></span><br><span class="line">db.Find(&amp;Pet{}) <span class="comment">// replicas `db3`/`db4`</span></span><br><span class="line">db.Save(&amp;Pet{}) <span class="comment">// sources `db2`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Orders Resolver 示例</span></span><br><span class="line">db.Find(&amp;Order{}) <span class="comment">// replicas `db8`</span></span><br><span class="line">db.Table(<span class="string">"orders"</span>).Find(&amp;Report{}) <span class="comment">// replicas `db8`</span></span><br></pre></td></tr></tbody></table></figure><h2 id="读写分离" class="article-heading"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离<a class="article-anchor" href="#读写分离" aria-hidden="true"></a></h2><p>DBResolver 的读写分离目前是基于 <a href="https://gorm.io/docs/write_plugins.html">GORM callback</a> 实现的。</p><p>对于 <code>Query</code>、<code>Row</code> callback，如果手动指定为 <code>Write</code> 模式，此时会使用 <code>sources</code>，否则使用 <code>replicas</code>。 对于 <code>Raw</code> callback，如果 SQL 是以 <code>SELECT</code> 开头，语句会被认为是只读的，会使用 <code>replicas</code>，否则会使用 <code>sources</code>。</p><h2 id="手动切换连接" class="article-heading"><a href="#手动切换连接" class="headerlink" title="手动切换连接"></a>手动切换连接<a class="article-anchor" href="#手动切换连接" aria-hidden="true"></a></h2><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Write 模式：从 sources db `db1` 读取 user</span></span><br><span class="line">db.Clauses(dbresolver.Write).First(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定 Resolver：从 `secondary` 的 replicas db `db8` 读取 user</span></span><br><span class="line">db.Clauses(dbresolver.Use(<span class="string">"secondary"</span>)).First(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定 Resolver 和 Write 模式：从 `secondary` 的 sources db `db6` 或 `db7` 读取 user</span></span><br><span class="line">db.Clauses(dbresolver.Use(<span class="string">"secondary"</span>), dbresolver.Write).First(&amp;user)</span><br></pre></td></tr></tbody></table></figure><h2 id="负载均衡" class="article-heading"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡<a class="article-anchor" href="#负载均衡" aria-hidden="true"></a></h2><p>GORM 支持基于策略的 sources/replicas 负载均衡，自定义策略应该是一个实现了以下接口的 struct：</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Policy <span class="keyword">interface</span> {</span><br><span class="line">    Resolve([]gorm.ConnPool) gorm.ConnPool</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当前只实现了一个 <code>RandomPolicy</code> 策略，如果没有指定其它策略，它就是默认策略。</p><h2 id="连接池" class="article-heading"><a href="#连接池" class="headerlink" title="连接池"></a>连接池<a class="article-anchor" href="#连接池" aria-hidden="true"></a></h2><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Use(</span><br><span class="line">  dbresolver.Register(dbresolver.Config{ <span class="comment">/* xxx */</span> }).</span><br><span class="line">  SetConnMaxIdleTime(time.Hour).</span><br><span class="line">  SetConnMaxLifetime(<span class="number">24</span> * time.Hour).</span><br><span class="line">  SetMaxIdleConns(<span class="number">100</span>).</span><br><span class="line">  SetMaxOpenConns(<span class="number">200</span>)</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure></body></html>              </div>